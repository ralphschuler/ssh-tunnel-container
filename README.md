# SSH Tunnel Container

This repository contains a minimal Docker setup for creating SSH port‑forwarding tunnels using a YAML configuration file.  It allows you to run a container that reads a config file and establishes one or more local port forwards from a remote server back to your host.  The project also ships with a GitHub Actions workflow that builds and publishes the Docker image to the GitHub Container Registry and enables Dependabot for automatic dependency updates and auto‑merging.

## Features

- **YAML configuration** – all connection details (remote host, user, identity file, and tunnels) are defined in a single YAML file.
- **Lightweight** – built on Alpine Linux with just Bash, `openssh‑client` and `yq` for parsing YAML, no Python or other heavy dependencies.
- **Automatic builds and releases** – GitHub Actions builds and pushes the Docker image on every push to `main` and when a GitHub Release is published.
- **Dependabot with auto‑merge** – dependency update pull requests generated by Dependabot are automatically grouped and merged when they pass CI.

## Getting Started

### 1. Prepare your SSH key

Ensure you have an SSH private key that can connect to your VPS.  The key should have appropriate permissions on the remote server to create port forwards but not necessarily a shell.  For added security you can restrict the key in the server’s `authorized_keys` file with options such as `command="/usr/bin/true"`, `permitopen`, and `no‑pty`.

### 2. Create a configuration file

Create a YAML config file (e.g. `config.yml`) based on the following template:

```yaml
# The VPS connection details
host: vps.example.com
port: 22
user: youruser
identityFile: /ssh/id_ed25519

# Optional additional SSH options (one option per array entry)
sshOptions:
  - "-o"
  - "ServerAliveInterval=60"
  - "-o"
  - "ServerAliveCountMax=3"
  - "-o"
  - "ExitOnForwardFailure=yes"

# A list of tunnels to establish
tunnels:
  # Forward VPS localhost:80 to host port 8080
  - localPort: 8080
    remoteHost: localhost
    remotePort: 80
    bindAddress: 127.0.0.1

  # Forward VPS localhost:443 to host port 8443
  - localPort: 8443
    remoteHost: localhost
    remotePort: 443
    # bindAddress is optional; defaults to 127.0.0.1

```

The `bindAddress` field controls where on the host the forwarded port will be bound.  Use `127.0.0.1` to bind only to localhost, or `0.0.0.0` to expose the port on all interfaces.

### 3. Build and run the container locally

First build the image:

```bash
docker build -t ssh-tunnel:latest .
```

Then run the container with your config file and SSH key mounted.  If you are on Linux you can use the host network mode so that the forwarded ports are available directly on the host:

```bash
docker run --rm \
  --network host \
  -v $(pwd)/config.yml:/config/config.yml:ro \
  -v ~/.ssh/id_ed25519:/ssh/id_ed25519:ro \
  ssh-tunnel:latest
```

Alternatively you can map ports explicitly instead of using host networking:

```bash
docker run --rm \
  -p 8080:8080 \
  -p 8443:8443 \
  -v $(pwd)/config.yml:/config/config.yml:ro \
  -v ~/.ssh/id_ed25519:/ssh/id_ed25519:ro \
  ssh-tunnel:latest
```

### 4. Using the published image

The GitHub Actions workflow builds the Docker image and pushes it to the GitHub Container Registry.  You can pull the latest image directly:

```bash
docker pull ghcr.io/${OWNER}/${REPO}:latest
```

Replace `${OWNER}` and `${REPO}` with your GitHub user/organisation and repository name.  The image is also tagged with the short SHA of the commit for reproducibility.

### 5. Repository layout

```
repo/
├── Dockerfile             # Alpine based image with openssh-client, bash and yq
├── entrypoint.sh          # Reads YAML config and executes ssh with -L forwards
├── config.yml             # Example configuration file
├── LICENSE                # MIT License text
├── README.md              # You are reading it
├── .gitignore             # Standard ignores
├── .github/
│   ├── workflows/
│   │   ├── release.yml    # Build & push Docker image on push and release
│   │   └── dependabot-automerge.yml # Auto merge Dependabot PRs
│   └── dependabot.yml     # Dependabot configuration (Actions & Docker)
```

## Continuous Integration and Releases

This repository uses GitHub Actions to build and publish the Docker image automatically.  The workflow is triggered on pushes to the `main` branch and when a GitHub Release is published.  It logs in to the GitHub Container Registry using the GitHub‑provided `GITHUB_TOKEN`, builds the image using the Docker Buildx action, and pushes two tags: `latest` and the short commit SHA.  See [`.github/workflows/release.yml`](.github/workflows/release.yml) for details.

Dependabot is configured via [`.github/dependabot.yml`](.github/dependabot.yml) to check for updates to GitHub Actions and to the base Docker image on a weekly schedule.  The [auto‑merge workflow](.github/workflows/dependabot-automerge.yml) uses an off‑the‑shelf action to automatically merge Dependabot pull requests once they pass CI.

## License

This project is licensed under the MIT License.  See [LICENSE](LICENSE) for details.
